/* Generated by Opal 0.11.99.dev */
Opal.modules["base64"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$delete']);
  return (function($base, $parent_nesting) {
    function $Base64() {};
    var self = $Base64 = $module($base, 'Base64', $Base64);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Base64_decode64_1, TMP_Base64_encode64_2, TMP_Base64_strict_decode64_3, TMP_Base64_strict_encode64_4, TMP_Base64_urlsafe_decode64_5, TMP_Base64_urlsafe_encode64_6;

    
    
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var encode, decode;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    encode = Opal.global.btoa || function (input) {
      var str = String(input);
      /* jshint ignore:start */
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars, output = '';
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3/4);
        if (charCode > 0xFF) {
          self.$raise($$($nesting, 'ArgumentError'), "invalid character (failed: The string to be encoded contains characters outside of the Latin1 range.)");
        }
        block = block << 8 | charCode;
      }
      return output;
      /* jshint ignore:end */
    };

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    decode = Opal.global.atob || function (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid base64 (failed: The string to be decoded is not correctly encoded.)");
      }
      /* jshint ignore:start */
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
      /* jshint ignore:end */
    };
  ;
    Opal.defs(self, '$decode64', TMP_Base64_decode64_1 = function $$decode64(string) {
      var self = this;

      return decode(string.replace(/\r?\n/g, ''));
    }, TMP_Base64_decode64_1.$$arity = 1);
    Opal.defs(self, '$encode64', TMP_Base64_encode64_2 = function $$encode64(string) {
      var self = this;

      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    }, TMP_Base64_encode64_2.$$arity = 1);
    Opal.defs(self, '$strict_decode64', TMP_Base64_strict_decode64_3 = function $$strict_decode64(string) {
      var self = this;

      return decode(string);
    }, TMP_Base64_strict_decode64_3.$$arity = 1);
    Opal.defs(self, '$strict_encode64', TMP_Base64_strict_encode64_4 = function $$strict_encode64(string) {
      var self = this;

      return encode(string);
    }, TMP_Base64_strict_encode64_4.$$arity = 1);
    Opal.defs(self, '$urlsafe_decode64', TMP_Base64_urlsafe_decode64_5 = function $$urlsafe_decode64(string) {
      var self = this;

      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    }, TMP_Base64_urlsafe_decode64_5.$$arity = 1);
    Opal.defs(self, '$urlsafe_encode64', TMP_Base64_urlsafe_encode64_6 = function $$urlsafe_encode64(string, $kwargs) {
      var padding, self = this, str = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      padding = $kwargs.$$smap["padding"];
      if (padding == null) {
        padding = true
      };
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if ($truthy(padding)) {
      } else {
        str = str.$delete("=")
      };
      return str;
    }, TMP_Base64_urlsafe_encode64_6.$$arity = -2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["json"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$new', '$push', '$[]=', '$-', '$[]', '$create_id', '$json_create', '$const_get', '$attr_accessor', '$create_id=', '$===', '$parse', '$generate', '$from_object', '$merge', '$to_json', '$responds_to?', '$to_io', '$write', '$to_s', '$to_a', '$strftime']);
  
  (function($base, $parent_nesting) {
    function $JSON() {};
    var self = $JSON = $module($base, 'JSON', $JSON);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_JSON_$$_1, TMP_JSON_parse_2, TMP_JSON_parse$B_3, TMP_JSON_load_4, TMP_JSON_from_object_5, TMP_JSON_generate_6, TMP_JSON_dump_7, $writer = nil;

    
    (function($base, $super, $parent_nesting) {
      function $JSONError(){};
      var self = $JSONError = $klass($base, $super, 'JSONError', $JSONError);

      var def = self.prototype, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    (function($base, $super, $parent_nesting) {
      function $ParserError(){};
      var self = $ParserError = $klass($base, $super, 'ParserError', $ParserError);

      var def = self.prototype, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'JSONError'), $nesting);
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$($nesting, 'JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'null':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                (($writer = [k, to_opal(value[k], options)]), $send((hash), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]']($$($nesting, 'JSON').$create_id())) != nil) {
              return $$$('::', 'Object').$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      var def = self.prototype, $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    
    $writer = ["json_class"];
    $send(self, 'create_id=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    Opal.defs(self, '$[]', TMP_JSON_$$_1 = function(value, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      if ($truthy($$($nesting, 'String')['$==='](value))) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, TMP_JSON_$$_1.$$arity = -2);
    Opal.defs(self, '$parse', TMP_JSON_parse_2 = function $$parse(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})));
    }, TMP_JSON_parse_2.$$arity = -2);
    Opal.defs(self, '$parse!', TMP_JSON_parse$B_3 = function(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$parse(source, options);
    }, TMP_JSON_parse$B_3.$$arity = -2);
    Opal.defs(self, '$load', TMP_JSON_load_4 = function $$load(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$from_object($parse(source), options);
    }, TMP_JSON_load_4.$$arity = -2);
    Opal.defs(self, '$from_object', TMP_JSON_from_object_5 = function $$from_object(js_object, options) {
      var $a, self = this, $writer = nil;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      ($truthy($a = options['$[]']("object_class")) ? $a : (($writer = ["object_class", $$($nesting, 'Hash')]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      ($truthy($a = options['$[]']("array_class")) ? $a : (($writer = ["array_class", $$($nesting, 'Array')]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      return to_opal(js_object, options.$$smap);;
    }, TMP_JSON_from_object_5.$$arity = -2);
    Opal.defs(self, '$generate', TMP_JSON_generate_6 = function $$generate(obj, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return obj.$to_json(options);
    }, TMP_JSON_generate_6.$$arity = -2);
    Opal.defs(self, '$dump', TMP_JSON_dump_7 = function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      
      if (io == null) {
        io = nil;
      };
      
      if (limit == null) {
        limit = nil;
      };
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()};
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, TMP_JSON_dump_7.$$arity = -2);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Object_to_json_8;

    return (Opal.def(self, '$to_json', TMP_Object_to_json_8 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, TMP_Object_to_json_8.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    function $Enumerable() {};
    var self = $Enumerable = $module($base, 'Enumerable', $Enumerable);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Enumerable_to_json_9;

    
    Opal.def(self, '$to_json', TMP_Enumerable_to_json_9 = function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, TMP_Enumerable_to_json_9.$$arity = 0)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $Array(){};
    var self = $Array = $klass($base, $super, 'Array', $Array);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Array_to_json_10;

    return (Opal.def(self, '$to_json', TMP_Array_to_json_10 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(', ') + ']';
    
    }, TMP_Array_to_json_10.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Boolean(){};
    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Boolean_to_json_11;

    return (Opal.def(self, '$to_json', TMP_Boolean_to_json_11 = function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, TMP_Boolean_to_json_11.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Hash(){};
    var self = $Hash = $klass($base, $super, 'Hash', $Hash);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Hash_to_json_12;

    return (Opal.def(self, '$to_json', TMP_Hash_to_json_12 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(', ') + '}';
    
    }, TMP_Hash_to_json_12.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $NilClass(){};
    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_NilClass_to_json_13;

    return (Opal.def(self, '$to_json', TMP_NilClass_to_json_13 = function $$to_json() {
      var self = this;

      return "null"
    }, TMP_NilClass_to_json_13.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Numeric(){};
    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Numeric_to_json_14;

    return (Opal.def(self, '$to_json', TMP_Numeric_to_json_14 = function $$to_json() {
      var self = this;

      return self.toString();
    }, TMP_Numeric_to_json_14.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.prototype, $nesting = [self].concat($parent_nesting);

    return Opal.alias(self, "to_json", "inspect")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Time(){};
    var self = $Time = $klass($base, $super, 'Time', $Time);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Time_to_json_15;

    return (Opal.def(self, '$to_json', TMP_Time_to_json_15 = function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, TMP_Time_to_json_15.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    function $Date(){};
    var self = $Date = $klass($base, $super, 'Date', $Date);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Date_to_json_16, TMP_Date_as_json_17;

    
    
    Opal.def(self, '$to_json', TMP_Date_to_json_16 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, TMP_Date_to_json_16.$$arity = 0);
    return (Opal.def(self, '$as_json', TMP_Date_as_json_17 = function $$as_json() {
      var self = this;

      return self.$to_s()
    }, TMP_Date_as_json_17.$$arity = 0), nil) && 'as_json';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal/source_map/map"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$require', '$map', '$to_json', '$to_h', '$to_s', '$delete', '$encode64']);
  
  self.$require("base64");
  self.$require("json");
  return (function($base, $parent_nesting) {
    function $Map() {};
    var self = $Map = $module($base, 'Map', $Map);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Map_to_h_1, TMP_Map_to_json_2, TMP_Map_as_json_3, TMP_Map_to_s_4, TMP_Map_to_data_uri_comment_5;

    
    
    Opal.def(self, '$to_h', TMP_Map_to_h_1 = function $$to_h() {
      var self = this;

      return self.$map()
    }, TMP_Map_to_h_1.$$arity = 0);
    
    Opal.def(self, '$to_json', TMP_Map_to_json_2 = function $$to_json() {
      var self = this;

      return self.$map().$to_json()
    }, TMP_Map_to_json_2.$$arity = 0);
    
    Opal.def(self, '$as_json', TMP_Map_as_json_3 = function $$as_json($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$to_h();
    }, TMP_Map_as_json_3.$$arity = -1);
    
    Opal.def(self, '$to_s', TMP_Map_to_s_4 = function $$to_s() {
      var self = this;

      return self.$map().$to_s()
    }, TMP_Map_to_s_4.$$arity = 0);
    
    Opal.def(self, '$to_data_uri_comment', TMP_Map_to_data_uri_comment_5 = function $$to_data_uri_comment() {
      var self = this;

      return "" + "//# sourceMappingURL=data:application/json;base64," + ($$($nesting, 'Base64').$encode64(self.$to_json()).$delete("\n"))
    }, TMP_Map_to_data_uri_comment_5.$$arity = 0);
  })($$$($$($nesting, 'Opal'), 'SourceMap'), $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal/source_map/file"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$include', '$attr_reader', '$new', '$size', '$[]=', '$-', '$join', '$map', '$to_proc', '$file', '$force_encoding', '$source', '$names', '$encode_mappings', '$relative_mappings', '$absolute_mappings', '$sort_by', '$to_a', '$line', '$column', '$source_map_name', '$[]', '$to_s', '$to_int', '$each', '$fragments_by_line', '$<<', '$segment_from_fragment', '$+', '$private', '$flat_map', '$fragments', '$code', '$split', '$with_index', '$zero?', '$!', '$last']);
  return (function($base, $super, $parent_nesting) {
    function $File(){};
    var self = $File = $klass($base, $super, 'File', $File);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_File_initialize_1, TMP_File_generated_code_3, TMP_File_map_4, TMP_File_names_5, TMP_File_segment_from_fragment_8, TMP_File_relative_mappings_9, TMP_File_absolute_mappings_12, TMP_File_fragments_by_line_15;

    def.generated_code = def.fragments = def.names = def.names_map = def.relative_mappings = def.absolute_mappings = nil;
    
    self.$include($$$($$$($$($nesting, 'Opal'), 'SourceMap'), 'Map'));
    self.$attr_reader("fragments");
    self.$attr_reader("file");
    self.$attr_reader("source");
    
    Opal.def(self, '$initialize', TMP_File_initialize_1 = function $$initialize(fragments, file, source) {
      var TMP_2, self = this;

      
      self.fragments = fragments;
      self.file = file;
      self.source = source;
      self.names_map = $send($$($nesting, 'Hash'), 'new', [], (TMP_2 = function(hash, name){var self = TMP_2.$$s || this, $writer = nil;

      
        
        if (hash == null) {
          hash = nil;
        };
        
        if (name == null) {
          name = nil;
        };
        $writer = [name, hash.$size()];
        $send(hash, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2));
      return (self.absolute_mappings = nil);
    }, TMP_File_initialize_1.$$arity = 3);
    
    Opal.def(self, '$generated_code', TMP_File_generated_code_3 = function $$generated_code() {
      var $a, self = this;

      return (self.generated_code = ($truthy($a = self.generated_code) ? $a : $send(self.fragments, 'map', [], "code".$to_proc()).$join()))
    }, TMP_File_generated_code_3.$$arity = 0);
    
    Opal.def(self, '$map', TMP_File_map_4 = function $$map($kwargs) {
      var source_root, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      source_root = $kwargs.$$smap["source_root"];
      if (source_root == null) {
        source_root = ""
      };
      return $hash2(["version", "sourceRoot", "sources", "sourcesContent", "names", "mappings"], {"version": 3, "sourceRoot": source_root, "sources": [self.$file()], "sourcesContent": [self.$source().$force_encoding("UTF-8")], "names": self.$names(), "mappings": $$$($$$($$($nesting, 'Opal'), 'SourceMap'), 'VLQ').$encode_mappings(self.$relative_mappings())});
    }, TMP_File_map_4.$$arity = -1);
    
    Opal.def(self, '$names', TMP_File_names_5 = function $$names() {
      var $a, TMP_6, TMP_7, self = this;

      return (self.names = ($truthy($a = self.names) ? $a : (self.$absolute_mappings(), $send($send(self.names_map.$to_a(), 'sort_by', [], (TMP_6 = function(_, index){var self = TMP_6.$$s || this;

      
        
        if (_ == null) {
          _ = nil;
        };
        
        if (index == null) {
          index = nil;
        };
        return index;}, TMP_6.$$s = self, TMP_6.$$arity = 2, TMP_6)), 'map', [], (TMP_7 = function(name, _){var self = TMP_7.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (_ == null) {
          _ = nil;
        };
        return name;}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7)))))
    }, TMP_File_names_5.$$arity = 0);
    
    Opal.def(self, '$segment_from_fragment', TMP_File_segment_from_fragment_8 = function $$segment_from_fragment(fragment, generated_column) {
      var $a, self = this, source_index = nil, original_line = nil, original_column = nil, map_name_index = nil, $writer = nil;

      
      source_index = 0;
      original_line = $rb_minus(fragment.$line(), 1);
      original_column = fragment.$column();
      if ($truthy(fragment.$source_map_name())) {
        
        map_name_index = ($truthy($a = self.names_map['$[]'](fragment.$source_map_name().$to_s())) ? $a : (($writer = [fragment.$source_map_name().$to_s(), self.names_map.$size()]), $send(self.names_map, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        return [generated_column, source_index, original_line, original_column, map_name_index];
      } else {
        return [generated_column, source_index, original_line, original_column]
      };
    }, TMP_File_segment_from_fragment_8.$$arity = 2);
    
    Opal.def(self, '$relative_mappings', TMP_File_relative_mappings_9 = function $$relative_mappings() {
      var $a, TMP_10, self = this, reference_segment = nil, reference_name_index = nil;

      return (self.relative_mappings = ($truthy($a = self.relative_mappings) ? $a : ((reference_segment = [0, 0, 0, 0, 0]), (reference_name_index = 0), $send(self.$absolute_mappings(), 'map', [], (TMP_10 = function(absolute_mapping){var self = TMP_10.$$s || this, TMP_11, $writer = nil;

      
        
        if (absolute_mapping == null) {
          absolute_mapping = nil;
        };
        
        $writer = [0, 0];
        $send(reference_segment, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return $send(absolute_mapping, 'map', [], (TMP_11 = function(absolute_segment){var self = TMP_11.$$s || this, $b, segment = nil;

        
          
          if (absolute_segment == null) {
            absolute_segment = nil;
          };
          segment = [];
          
          $writer = [0, $rb_minus(absolute_segment['$[]'](0), reference_segment['$[]'](0))];
          $send(segment, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [1, $rb_minus(absolute_segment['$[]'](1), ($truthy($b = reference_segment['$[]'](1)) ? $b : 0))];
          $send(segment, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [2, $rb_minus(absolute_segment['$[]'](2), ($truthy($b = reference_segment['$[]'](2)) ? $b : 0))];
          $send(segment, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [3, $rb_minus(absolute_segment['$[]'](3), ($truthy($b = reference_segment['$[]'](3)) ? $b : 0))];
          $send(segment, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(absolute_segment['$[]'](4))) {
            
            
            $writer = [4, $rb_minus(absolute_segment['$[]'](4).$to_int(), ($truthy($b = reference_segment['$[]'](4)) ? $b : reference_name_index).$to_int())];
            $send(segment, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            reference_name_index = absolute_segment['$[]'](4);};
          reference_segment = absolute_segment;
          return segment;}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)))))
    }, TMP_File_relative_mappings_9.$$arity = 0);
    
    Opal.def(self, '$absolute_mappings', TMP_File_absolute_mappings_12 = function $$absolute_mappings() {
      var $a, TMP_13, self = this, mappings = nil;

      return (self.absolute_mappings = ($truthy($a = self.absolute_mappings) ? $a : ((mappings = []), $send(self.$fragments_by_line(), 'each', [], (TMP_13 = function(raw_segments){var self = TMP_13.$$s || this, TMP_14, generated_column = nil, segments = nil;

      
        
        if (raw_segments == null) {
          raw_segments = nil;
        };
        generated_column = 0;
        segments = [];
        $send(raw_segments, 'each', [], (TMP_14 = function($mlhs_tmp1){var self = TMP_14.$$s || this, $b, $c, generated_code = nil, fragment = nil;

        
          
          if ($mlhs_tmp1 == null) {
            $mlhs_tmp1 = nil;
          };
          $c = $mlhs_tmp1, $b = Opal.to_ary($c), (generated_code = ($b[0] == null ? nil : $b[0])), (fragment = ($b[1] == null ? nil : $b[1])), $c;
          if ($truthy(($truthy($b = fragment.$line()) ? fragment.$column() : $b))) {
            segments['$<<'](self.$segment_from_fragment(fragment, generated_column))};
          return (generated_column = $rb_plus(generated_column, generated_code.$size()));}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14.$$has_top_level_mlhs_arg = true, TMP_14));
        return mappings['$<<'](segments);}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13)), mappings)))
    }, TMP_File_absolute_mappings_12.$$arity = 0);
    self.$private();
    return (Opal.def(self, '$fragments_by_line', TMP_File_fragments_by_line_15 = function $$fragments_by_line() {
      var TMP_16, self = this, raw_mappings = nil;

      
      raw_mappings = [[]];
      $send(self.$fragments(), 'flat_map', [], (TMP_16 = function(fragment){var self = TMP_16.$$s || this, TMP_17, fragment_code = nil, fragment_lines = nil;

      
        
        if (fragment == null) {
          fragment = nil;
        };
        fragment_code = fragment.$code();
        fragment_lines = fragment_code.$split("\n", -1);
        return $send(fragment_lines.$each(), 'with_index', [], (TMP_17 = function(fragment_line, index){var self = TMP_17.$$s || this, $a, raw_segment = nil;

        
          
          if (fragment_line == null) {
            fragment_line = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          raw_segment = [fragment_line, fragment];
          if ($truthy(($truthy($a = index['$zero?']()) ? fragment_line.$size()['$zero?']()['$!']() : $a))) {
            return raw_mappings.$last()['$<<'](raw_segment)
          } else if ($truthy(($truthy($a = index['$zero?']()) ? fragment_line.$size()['$zero?']() : $a))) {
            return nil
          } else if ($truthy(fragment_line.$size()['$zero?']())) {
            return raw_mappings['$<<']([])
          } else {
            return raw_mappings['$<<']([raw_segment])
          };}, TMP_17.$$s = self, TMP_17.$$arity = 2, TMP_17));}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));
      return raw_mappings;
    }, TMP_File_fragments_by_line_15.$$arity = 0), nil) && 'fragments_by_line';
  })($$$($$($nesting, 'Opal'), 'SourceMap'), null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal/source_map/index"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$attr_reader', '$map', '$to_h', '$generated_code', '$+', '$count', '$[]', '$rindex', '$size']);
  return (function($base, $super, $parent_nesting) {
    function $Index(){};
    var self = $Index = $klass($base, $super, 'Index', $Index);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_Index_initialize_1, TMP_Index_map_2;

    def.source_maps = nil;
    
    self.$include($$$($$$($$($nesting, 'Opal'), 'SourceMap'), 'Map'));
    self.$attr_reader("source_maps");
    
    Opal.def(self, '$initialize', TMP_Index_initialize_1 = function $$initialize(source_maps, $kwargs) {
      var join, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      join = $kwargs.$$smap["join"];
      if (join == null) {
        join = nil
      };
      self.source_maps = source_maps;
      return (self.join = join);
    }, TMP_Index_initialize_1.$$arity = -2);
    return (Opal.def(self, '$map', TMP_Index_map_2 = function $$map() {
      var TMP_3, self = this, offset_line = nil, offset_column = nil;

      
      offset_line = 0;
      offset_column = 0;
      return $hash2(["version", "sections"], {"version": 3, "sections": $send(self.source_maps, 'map', [], (TMP_3 = function(source_map){var self = TMP_3.$$s || this, map = nil, generated_code = nil, new_lines_count = nil, last_line = nil;
        if (self.join == null) self.join = nil;

      
        
        if (source_map == null) {
          source_map = nil;
        };
        map = $hash2(["offset", "map"], {"offset": $hash2(["line", "column"], {"line": offset_line, "column": offset_column}), "map": source_map.$to_h()});
        generated_code = source_map.$generated_code();
        if ($truthy(self.join)) {
          generated_code = $rb_plus(generated_code, self.join)};
        new_lines_count = generated_code.$count("\n");
        last_line = generated_code['$[]'](Opal.Range.$new($rb_plus(generated_code.$rindex("\n"), 1), -1, false));
        offset_line = $rb_plus(offset_line, new_lines_count);
        offset_column = $rb_plus(offset_column, last_line.$size());
        return map;}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))});
    }, TMP_Index_map_2.$$arity = 0), nil) && 'map';
  })($$$($$($nesting, 'Opal'), 'SourceMap'), null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal/source_map/vlq"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$<<', '$-', '$split', '$inject', '$[]', '$[]=', '$each', '$<', '$+', '$-@', '$loop', '$&', '$>>', '$>', '$|', '$join', '$any?', '$shift', '$raise', '$==', '$map', '$encode', '$each_with_index', '$decode']);
  return (function($base, $parent_nesting) {
    function $VLQ() {};
    var self = $VLQ = $module($base, 'VLQ', $VLQ);

    var def = self.prototype, $nesting = [self].concat($parent_nesting), TMP_VLQ_1, TMP_VLQ_encode_2, TMP_VLQ_decode_5, TMP_VLQ_encode_mappings_6, TMP_VLQ_decode_mappings_9;

    
    Opal.const_set($nesting[0], 'VLQ_BASE_SHIFT', 5);
    Opal.const_set($nesting[0], 'VLQ_BASE', (1)['$<<']($$($nesting, 'VLQ_BASE_SHIFT')));
    Opal.const_set($nesting[0], 'VLQ_BASE_MASK', $rb_minus($$($nesting, 'VLQ_BASE'), 1));
    Opal.const_set($nesting[0], 'VLQ_CONTINUATION_BIT', $$($nesting, 'VLQ_BASE'));
    Opal.const_set($nesting[0], 'BASE64_DIGITS', "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".$split(""));
    Opal.const_set($nesting[0], 'BASE64_VALUES', $send($range(0, 64, true), 'inject', [$hash2([], {})], (TMP_VLQ_1 = function(h, i){var self = TMP_VLQ_1.$$s || this, $writer = nil;

    
      
      if (h == null) {
        h = nil;
      };
      
      if (i == null) {
        i = nil;
      };
      
      $writer = [$$($nesting, 'BASE64_DIGITS')['$[]'](i), i];
      $send(h, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return h;}, TMP_VLQ_1.$$s = self, TMP_VLQ_1.$$arity = 2, TMP_VLQ_1)));
    Opal.defs(self, '$encode', TMP_VLQ_encode_2 = function $$encode(ary) {
      var TMP_3, self = this, result = nil;

      
      result = [];
      (function(){var $brk = Opal.new_brk(); try {return $send(ary, 'each', [], (TMP_3 = function(n){var self = TMP_3.$$s || this, TMP_4, vlq = nil;

      
        
        if (n == null) {
          n = nil;
        };
        vlq = (function() {if ($truthy($rb_lt(n, 0))) {
          return $rb_plus(n['$-@']()['$<<'](1), 1)
        } else {
          return n['$<<'](1)
        }; return nil; })();
        return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_4 = function(){var self = TMP_4.$$s || this, digit = nil;

        
          digit = vlq['$&']($$($nesting, 'VLQ_BASE_MASK'));
          vlq = vlq['$>>']($$($nesting, 'VLQ_BASE_SHIFT'));
          if ($truthy($rb_gt(vlq, 0))) {
            digit = digit['$|']($$($nesting, 'VLQ_CONTINUATION_BIT'))};
          result['$<<']($$($nesting, 'BASE64_DIGITS')['$[]'](digit));
          if ($truthy($rb_gt(vlq, 0))) {
            return nil
          } else {
            
            Opal.brk(nil, $brk)
          };}, TMP_4.$$s = self, TMP_4.$$brk = $brk, TMP_4.$$arity = 0, TMP_4))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();}, TMP_3.$$s = self, TMP_3.$$brk = $brk, TMP_3.$$arity = 1, TMP_3))
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      return result.$join();
    }, TMP_VLQ_encode_2.$$arity = 1);
    Opal.defs(self, '$decode', TMP_VLQ_decode_5 = function $$decode(str) {
      var $a, $b, self = this, result = nil, chars = nil, vlq = nil, shift = nil, continuation = nil, char$ = nil, digit = nil;

      
      result = [];
      chars = str.$split("");
      while ($truthy(chars['$any?']())) {
        
        vlq = 0;
        shift = 0;
        continuation = true;
        while ($truthy(continuation)) {
          
          char$ = chars.$shift();
          if ($truthy(char$)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'))
          };
          digit = $$($nesting, 'BASE64_VALUES')['$[]'](char$);
          if (digit['$&']($$($nesting, 'VLQ_CONTINUATION_BIT'))['$=='](0)) {
            continuation = false};
          digit = digit['$&']($$($nesting, 'VLQ_BASE_MASK'));
          vlq = $rb_plus(vlq, digit['$<<'](shift));
          shift = $rb_plus(shift, $$($nesting, 'VLQ_BASE_SHIFT'));
        };
        result['$<<']((function() {if (vlq['$&'](1)['$=='](1)) {
          return vlq['$>>'](1)['$-@']()
        } else {
          return vlq['$>>'](1)
        }; return nil; })());
      };
      return result;
    }, TMP_VLQ_decode_5.$$arity = 1);
    Opal.defs(self, '$encode_mappings', TMP_VLQ_encode_mappings_6 = function $$encode_mappings(ary) {
      var TMP_7, self = this;

      return $send(ary, 'map', [], (TMP_7 = function(group){var self = TMP_7.$$s || this, TMP_8;

      
        
        if (group == null) {
          group = nil;
        };
        return $send(group, 'map', [], (TMP_8 = function(segment){var self = TMP_8.$$s || this;

        
          
          if (segment == null) {
            segment = nil;
          };
          return self.$encode(segment);}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8)).$join(",");}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7)).$join(";")
    }, TMP_VLQ_encode_mappings_6.$$arity = 1);
    Opal.defs(self, '$decode_mappings', TMP_VLQ_decode_mappings_9 = function $$decode_mappings(str) {
      var TMP_10, self = this, mappings = nil;

      
      mappings = [];
      $send(str.$split(";"), 'each_with_index', [], (TMP_10 = function(group, index){var self = TMP_10.$$s || this, TMP_11, $writer = nil;

      
        
        if (group == null) {
          group = nil;
        };
        
        if (index == null) {
          index = nil;
        };
        
        $writer = [index, []];
        $send(mappings, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return $send(group.$split(","), 'each', [], (TMP_11 = function(segment){var self = TMP_11.$$s || this;

        
          
          if (segment == null) {
            segment = nil;
          };
          return mappings['$[]'](index)['$<<'](self.$decode(segment));}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10));
      return mappings;
    }, TMP_VLQ_decode_mappings_9.$$arity = 1);
  })($$$($$($nesting, 'Opal'), 'SourceMap'), $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal/source_map"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$autoload']);
  return (function($base, $parent_nesting) {
    function $Opal() {};
    var self = $Opal = $module($base, 'Opal', $Opal);

    var def = self.prototype, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      function $SourceMap() {};
      var self = $SourceMap = $module($base, 'SourceMap', $SourceMap);

      var def = self.prototype, $nesting = [self].concat($parent_nesting);

      
      self.$autoload("Map", "opal/source_map/map");
      self.$autoload("File", "opal/source_map/file");
      self.$autoload("Index", "opal/source_map/index");
      self.$autoload("VLQ", "opal/source_map/vlq");
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal-source-maps"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  return self.$require("opal/source_map")
};
