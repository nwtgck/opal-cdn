/* Generated by Opal 0.11.4 */
Opal.modules["json"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$new', '$push', '$[]=', '$-', '$[]', '$create_id', '$json_create', '$const_get', '$attr_accessor', '$create_id=', '$===', '$parse', '$generate', '$from_object', '$merge', '$to_json', '$responds_to?', '$to_io', '$write', '$to_s', '$to_a', '$strftime']);
  
  (function($base, $parent_nesting) {
    var $JSON, self = $JSON = $module($base, 'JSON');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JSON_$$_1, TMP_JSON_parse_2, TMP_JSON_parse$B_3, TMP_JSON_load_4, TMP_JSON_from_object_5, TMP_JSON_generate_6, TMP_JSON_dump_7, $writer = nil;

    
    (function($base, $super, $parent_nesting) {
      function $JSONError(){};
      var self = $JSONError = $klass($base, $super, 'JSONError', $JSONError);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
    (function($base, $super, $parent_nesting) {
      function $ParserError(){};
      var self = $ParserError = $klass($base, $super, 'ParserError', $ParserError);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], Opal.const_get_relative($nesting, 'JSONError'), $nesting);
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'null':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                (($writer = [k, to_opal(value[k], options)]), $send((hash), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]'](Opal.const_get_relative($nesting, 'JSON').$create_id())) != nil) {
              return Opal.const_get_qualified('::', 'Object').$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    
    $writer = ["json_class"];
    $send(self, 'create_id=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    Opal.defs(self, '$[]', TMP_JSON_$$_1 = function(value, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](value))) {
        return self.$parse(value, options)
        } else {
        return self.$generate(value, options)
      }
    }, TMP_JSON_$$_1.$$arity = -2);
    Opal.defs(self, '$parse', TMP_JSON_parse_2 = function $$parse(source, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})))
    }, TMP_JSON_parse_2.$$arity = -2);
    Opal.defs(self, '$parse!', TMP_JSON_parse$B_3 = function(source, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      return self.$parse(source, options)
    }, TMP_JSON_parse$B_3.$$arity = -2);
    Opal.defs(self, '$load', TMP_JSON_load_4 = function $$load(source, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      return self.$from_object($parse(source), options)
    }, TMP_JSON_load_4.$$arity = -2);
    Opal.defs(self, '$from_object', TMP_JSON_from_object_5 = function $$from_object(js_object, options) {
      var $a, self = this, $writer = nil;

      if (options == null) {
        options = $hash2([], {});
      }
      
      ($truthy($a = options['$[]']("object_class")) ? $a : (($writer = ["object_class", Opal.const_get_relative($nesting, 'Hash')]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      ($truthy($a = options['$[]']("array_class")) ? $a : (($writer = ["array_class", Opal.const_get_relative($nesting, 'Array')]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      return to_opal(js_object, options.$$smap);
    }, TMP_JSON_from_object_5.$$arity = -2);
    Opal.defs(self, '$generate', TMP_JSON_generate_6 = function $$generate(obj, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      return obj.$to_json(options)
    }, TMP_JSON_generate_6.$$arity = -2);
    Opal.defs(self, '$dump', TMP_JSON_dump_7 = function $$dump(obj, io, limit) {
      var self = this, string = nil;

      if (io == null) {
        io = nil;
      }
      if (limit == null) {
        limit = nil;
      }
      
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()};
        io.$write(string);
        return io;
        } else {
        return string
      };
    }, TMP_JSON_dump_7.$$arity = -2);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Object_to_json_8;

    return (Opal.defn(self, '$to_json', TMP_Object_to_json_8 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, TMP_Object_to_json_8.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var $Enumerable, self = $Enumerable = $module($base, 'Enumerable');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerable_to_json_9;

    
    Opal.defn(self, '$to_json', TMP_Enumerable_to_json_9 = function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, TMP_Enumerable_to_json_9.$$arity = 0)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $Array(){};
    var self = $Array = $klass($base, $super, 'Array', $Array);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_to_json_10;

    return (Opal.defn(self, '$to_json', TMP_Array_to_json_10 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(', ') + ']';
    
    }, TMP_Array_to_json_10.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Boolean(){};
    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Boolean_to_json_11;

    return (Opal.defn(self, '$to_json', TMP_Boolean_to_json_11 = function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false'
    }, TMP_Boolean_to_json_11.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Hash(){};
    var self = $Hash = $klass($base, $super, 'Hash', $Hash);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_to_json_12;

    return (Opal.defn(self, '$to_json', TMP_Hash_to_json_12 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(', ') + '}';
    
    }, TMP_Hash_to_json_12.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $NilClass(){};
    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_to_json_13;

    return (Opal.defn(self, '$to_json', TMP_NilClass_to_json_13 = function $$to_json() {
      var self = this;

      return "null"
    }, TMP_NilClass_to_json_13.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Numeric(){};
    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_to_json_14;

    return (Opal.defn(self, '$to_json', TMP_Numeric_to_json_14 = function $$to_json() {
      var self = this;

      return self.toString()
    }, TMP_Numeric_to_json_14.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return Opal.alias(self, "to_json", "inspect")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Time(){};
    var self = $Time = $klass($base, $super, 'Time', $Time);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Time_to_json_15;

    return (Opal.defn(self, '$to_json', TMP_Time_to_json_15 = function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, TMP_Time_to_json_15.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    function $Date(){};
    var self = $Date = $klass($base, $super, 'Date', $Date);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Date_to_json_16, TMP_Date_as_json_17;

    
    
    Opal.defn(self, '$to_json', TMP_Date_to_json_16 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, TMP_Date_to_json_16.$$arity = 0);
    return (Opal.defn(self, '$as_json', TMP_Date_as_json_17 = function $$as_json() {
      var self = this;

      return self.$to_s()
    }, TMP_Date_as_json_17.$$arity = 0), nil) && 'as_json';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["source_map/offset"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$first', '$===', '$attr_reader', '$new', '$+', '$line', '$column', '$raise', '$class', '$-', '$zero?', '$==']);
  return (function($base, $parent_nesting) {
    var $SourceMap, self = $SourceMap = $module($base, 'SourceMap');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Offset(){};
      var self = $Offset = $klass($base, $super, 'Offset', $Offset);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Offset_new_1, TMP_Offset_initialize_2, TMP_Offset_$_3, TMP_Offset_$lt$eq$gt_4, TMP_Offset_to_s_5, TMP_Offset_inspect_6;

      
      self.$include(Opal.const_get_relative($nesting, 'Comparable'));
      Opal.defs(self, '$new', TMP_Offset_new_1 = function($a_rest) {
        var self = this, args, $iter = TMP_Offset_new_1.$$p, $yield = $iter || nil, $case = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
        if ($iter) TMP_Offset_new_1.$$p = null;
        return (function() {$case = args.$first();
        if (Opal.const_get_relative($nesting, 'Offset')['$===']($case)) {return args.$first()}
        else if (Opal.const_get_relative($nesting, 'Array')['$===']($case)) {return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Offset_new_1, false, $Offset), Opal.to_a(args.$first()), null)}
        else {return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Offset_new_1, false, $Offset), Opal.to_a(args), null)}})()
      }, TMP_Offset_new_1.$$arity = -1);
      
      Opal.defn(self, '$initialize', TMP_Offset_initialize_2 = function $$initialize(line, column) {
        var $a, self = this;

        return $a = [line, column], (self.line = $a[0]), (self.column = $a[1]), $a
      }, TMP_Offset_initialize_2.$$arity = 2);
      self.$attr_reader("line");
      self.$attr_reader("column");
      
      Opal.defn(self, '$+', TMP_Offset_$_3 = function(other) {
        var self = this, $case = nil;

        return (function() {$case = other;
        if (Opal.const_get_relative($nesting, 'Offset')['$===']($case)) {return Opal.const_get_relative($nesting, 'Offset').$new($rb_plus(self.$line(), other.$line()), $rb_plus(self.$column(), other.$column()))}
        else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return Opal.const_get_relative($nesting, 'Offset').$new($rb_plus(self.$line(), other), self.$column())}
        else {return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "can't convert " + (other) + " into " + (self.$class()))}})()
      }, TMP_Offset_$_3.$$arity = 1);
      
      Opal.defn(self, '$<=>', TMP_Offset_$lt$eq$gt_4 = function(other) {
        var self = this, $case = nil, diff = nil;

        return (function() {$case = other;
        if (Opal.const_get_relative($nesting, 'Offset')['$===']($case)) {
        diff = $rb_minus(self.$line(), other.$line());
        if ($truthy(diff['$zero?']())) {
          return $rb_minus(self.$column(), other.$column())
          } else {
          return diff
        };}
        else {return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "can't convert " + (other.$class()) + " into " + (self.$class()))}})()
      }, TMP_Offset_$lt$eq$gt_4.$$arity = 1);
      
      Opal.defn(self, '$to_s', TMP_Offset_to_s_5 = function $$to_s() {
        var self = this;

        if (self.$column()['$=='](0)) {
          return "" + (self.$line())
          } else {
          return "" + (self.$line()) + ":" + (self.$column())
        }
      }, TMP_Offset_to_s_5.$$arity = 0);
      return (Opal.defn(self, '$inspect', TMP_Offset_inspect_6 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + " line=" + (self.$line()) + ", column=" + (self.$column()) + ">"
      }, TMP_Offset_inspect_6.$$arity = 0), nil) && 'inspect';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["source_map/mapping"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$line', '$generated', '$column', '$<<', '$source', '$original', '$name', '$class', '$inspect', '$new']);
  
  self.$require("source_map/offset");
  return (function($base, $parent_nesting) {
    var $SourceMap, self = $SourceMap = $module($base, 'SourceMap');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Mapping(){};
      var self = $Mapping = $klass($base, $super, 'Mapping', $Mapping);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Mapping_to_s_1, TMP_Mapping_inspect_2;

      
      
      Opal.defn(self, '$to_s', TMP_Mapping_to_s_1 = function $$to_s() {
        var self = this, str = nil;

        
        str = "" + (self.$generated().$line()) + ":" + (self.$generated().$column());
        str['$<<']("" + "->" + (self.$source()) + "@" + (self.$original().$line()) + ":" + (self.$original().$column()));
        if ($truthy(self.$name())) {
          str['$<<']("" + "#" + (self.$name()))};
        return str;
      }, TMP_Mapping_to_s_1.$$arity = 0);
      return (Opal.defn(self, '$inspect', TMP_Mapping_inspect_2 = function $$inspect() {
        var self = this, str = nil;

        
        str = "" + "#<" + (self.$class()) + " source=" + (self.$source().$inspect());
        str['$<<']("" + " generated=" + (self.$generated()) + ", original=" + (self.$original()));
        if ($truthy(self.$name())) {
          str['$<<']("" + " name=" + (self.$name().$inspect()))};
        str['$<<'](">");
        return str;
      }, TMP_Mapping_inspect_2.$$arity = 0), nil) && 'inspect';
    })($nesting[0], Opal.const_get_relative($nesting, 'Struct').$new("source", "generated", "original", "name"), $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["source_map/vlq"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$<<', '$-', '$split', '$inject', '$[]', '$[]=', '$each', '$<', '$+', '$-@', '$loop', '$&', '$>>', '$>', '$|', '$join', '$any?', '$shift', '$raise', '$==', '$map', '$encode', '$each_with_index', '$decode']);
  return (function($base, $parent_nesting) {
    var $SourceMap, self = $SourceMap = $module($base, 'SourceMap');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $VLQ, self = $VLQ = $module($base, 'VLQ');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_VLQ_1, TMP_VLQ_encode_4, TMP_VLQ_decode_5, TMP_VLQ_encode_mappings_8, TMP_VLQ_decode_mappings_11;

      
      Opal.const_set($nesting[0], 'VLQ_BASE_SHIFT', 5);
      Opal.const_set($nesting[0], 'VLQ_BASE', (1)['$<<'](Opal.const_get_relative($nesting, 'VLQ_BASE_SHIFT')));
      Opal.const_set($nesting[0], 'VLQ_BASE_MASK', $rb_minus(Opal.const_get_relative($nesting, 'VLQ_BASE'), 1));
      Opal.const_set($nesting[0], 'VLQ_CONTINUATION_BIT', Opal.const_get_relative($nesting, 'VLQ_BASE'));
      Opal.const_set($nesting[0], 'BASE64_DIGITS', "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".$split(""));
      Opal.const_set($nesting[0], 'BASE64_VALUES', $send($range(0, 64, true), 'inject', [$hash2([], {})], (TMP_VLQ_1 = function(h, i){var self = TMP_VLQ_1.$$s || this, $writer = nil;
if (h == null) h = nil;if (i == null) i = nil;
      
        
        $writer = [Opal.const_get_relative($nesting, 'BASE64_DIGITS')['$[]'](i), i];
        $send(h, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return h;}, TMP_VLQ_1.$$s = self, TMP_VLQ_1.$$arity = 2, TMP_VLQ_1)));
      Opal.defs(self, '$encode', TMP_VLQ_encode_4 = function $$encode(ary) {
        var TMP_2, self = this, result = nil;

        
        result = [];
        (function(){var $brk = Opal.new_brk(); try {return $send(ary, 'each', [], (TMP_2 = function(n){var self = TMP_2.$$s || this, TMP_3, vlq = nil;
if (n == null) n = nil;
        
          vlq = (function() {if ($truthy($rb_lt(n, 0))) {
            return $rb_plus(n['$-@']()['$<<'](1), 1)
            } else {
            return n['$<<'](1)
          }; return nil; })();
          return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_3 = function(){var self = TMP_3.$$s || this, digit = nil;

          
            digit = vlq['$&'](Opal.const_get_relative($nesting, 'VLQ_BASE_MASK'));
            vlq = vlq['$>>'](Opal.const_get_relative($nesting, 'VLQ_BASE_SHIFT'));
            if ($truthy($rb_gt(vlq, 0))) {
              digit = digit['$|'](Opal.const_get_relative($nesting, 'VLQ_CONTINUATION_BIT'))};
            result['$<<'](Opal.const_get_relative($nesting, 'BASE64_DIGITS')['$[]'](digit));
            if ($truthy($rb_gt(vlq, 0))) {
              return nil
              } else {
              
              Opal.brk(nil, $brk)
            };}, TMP_3.$$s = self, TMP_3.$$brk = $brk, TMP_3.$$arity = 0, TMP_3))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();}, TMP_2.$$s = self, TMP_2.$$brk = $brk, TMP_2.$$arity = 1, TMP_2))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        return result.$join();
      }, TMP_VLQ_encode_4.$$arity = 1);
      Opal.defs(self, '$decode', TMP_VLQ_decode_5 = function $$decode(str) {
        var $a, $b, self = this, result = nil, chars = nil, vlq = nil, shift = nil, continuation = nil, char$ = nil, digit = nil;

        
        result = [];
        chars = str.$split("");
        while ($truthy(chars['$any?']())) {
          
          vlq = 0;
          shift = 0;
          continuation = true;
          while ($truthy(continuation)) {
            
            char$ = chars.$shift();
            if ($truthy(char$)) {
              } else {
              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'))
            };
            digit = Opal.const_get_relative($nesting, 'BASE64_VALUES')['$[]'](char$);
            if (digit['$&'](Opal.const_get_relative($nesting, 'VLQ_CONTINUATION_BIT'))['$=='](0)) {
              continuation = false};
            digit = digit['$&'](Opal.const_get_relative($nesting, 'VLQ_BASE_MASK'));
            vlq = $rb_plus(vlq, digit['$<<'](shift));
            shift = $rb_plus(shift, Opal.const_get_relative($nesting, 'VLQ_BASE_SHIFT'));
          };
          result['$<<']((function() {if (vlq['$&'](1)['$=='](1)) {
            return vlq['$>>'](1)['$-@']()
            } else {
            return vlq['$>>'](1)
          }; return nil; })());
        };
        return result;
      }, TMP_VLQ_decode_5.$$arity = 1);
      Opal.defs(self, '$encode_mappings', TMP_VLQ_encode_mappings_8 = function $$encode_mappings(ary) {
        var TMP_6, self = this;

        return $send(ary, 'map', [], (TMP_6 = function(group){var self = TMP_6.$$s || this, TMP_7;
if (group == null) group = nil;
        return $send(group, 'map', [], (TMP_7 = function(segment){var self = TMP_7.$$s || this;
if (segment == null) segment = nil;
          return self.$encode(segment)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7)).$join(",")}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)).$join(";")
      }, TMP_VLQ_encode_mappings_8.$$arity = 1);
      Opal.defs(self, '$decode_mappings', TMP_VLQ_decode_mappings_11 = function $$decode_mappings(str) {
        var TMP_9, self = this, mappings = nil;

        
        mappings = [];
        $send(str.$split(";"), 'each_with_index', [], (TMP_9 = function(group, index){var self = TMP_9.$$s || this, TMP_10, $writer = nil;
if (group == null) group = nil;if (index == null) index = nil;
        
          
          $writer = [index, []];
          $send(mappings, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return $send(group.$split(","), 'each', [], (TMP_10 = function(segment){var self = TMP_10.$$s || this;
if (segment == null) segment = nil;
          return mappings['$[]'](index)['$<<'](self.$decode(segment))}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9));
        return mappings;
      }, TMP_VLQ_decode_mappings_11.$$arity = 1);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["source_map/map"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$include', '$from_hash', '$parse', '$[]', '$decode_vlq_mappings', '$new', '$each_with_index', '$decode_mappings', '$+', '$each', '$>=', '$size', '$<<', '$attr_reader', '$to_proc', '$build_vlq_string', '$compact', '$uniq', '$map', '$eql?', '$is_a?', '$class', '$==', '$mappings', '$filename', '$dup', '$any?', '$line', '$generated', '$last', '$source', '$original', '$name', '$empty?', '$bsearch', '$/', '$>', '$<', '$-', '$to_s', '$sources', '$names', '$inspect', '$protected', '$group_by', '$to_a', '$max', '$keys', '$column', '$encode_mappings']);
  
  self.$require("json");
  self.$require("source_map/offset");
  self.$require("source_map/mapping");
  self.$require("source_map/vlq");
  return (function($base, $parent_nesting) {
    var $SourceMap, self = $SourceMap = $module($base, 'SourceMap');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Map(){};
      var self = $Map = $klass($base, $super, 'Map', $Map);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Map_from_json_1, TMP_Map_from_hash_2, TMP_Map_decode_vlq_mappings_5, TMP_Map_initialize_6, TMP_Map_size_7, TMP_Map_$$_8, TMP_Map_each_9, TMP_Map_to_s_10, TMP_Map_sources_11, TMP_Map_names_12, TMP_Map_$eq$eq_13, TMP_Map_eql$q_14, TMP_Map_$_16, TMP_Map_$_18, TMP_Map_bsearch_19, TMP_Map_as_json_20, TMP_Map_inspect_21, TMP_Map_build_vlq_string_25;

      def.mappings = def.string = def.sources = def.names = nil;
      
      self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
      Opal.defs(self, '$from_json', TMP_Map_from_json_1 = function $$from_json(json) {
        var self = this;

        return self.$from_hash(Opal.const_get_relative($nesting, 'JSON').$parse(json))
      }, TMP_Map_from_json_1.$$arity = 1);
      Opal.defs(self, '$from_hash', TMP_Map_from_hash_2 = function $$from_hash(hash) {
        var self = this, str = nil, sources = nil, names = nil, mappings = nil;

        
        str = hash['$[]']("mappings");
        sources = hash['$[]']("sources");
        names = hash['$[]']("names");
        mappings = self.$decode_vlq_mappings(str, sources, names);
        return self.$new(mappings, hash['$[]']("file"));
      }, TMP_Map_from_hash_2.$$arity = 1);
      Opal.defs(self, '$decode_vlq_mappings', TMP_Map_decode_vlq_mappings_5 = function $$decode_vlq_mappings(str, sources, names) {
        var TMP_3, self = this, mappings = nil, source_id = nil, original_line = nil, original_column = nil, name_id = nil;

        if (sources == null) {
          sources = [];
        }
        if (names == null) {
          names = [];
        }
        
        mappings = [];
        source_id = 0;
        original_line = 1;
        original_column = 0;
        name_id = 0;
        $send(Opal.const_get_relative($nesting, 'VLQ').$decode_mappings(str), 'each_with_index', [], (TMP_3 = function(group, index){var self = TMP_3.$$s || this, TMP_4, generated_column = nil, generated_line = nil;
if (group == null) group = nil;if (index == null) index = nil;
        
          generated_column = 0;
          generated_line = $rb_plus(index, 1);
          return $send(group, 'each', [], (TMP_4 = function(segment){var self = TMP_4.$$s || this, generated = nil, source = nil, original = nil, name = nil;
if (segment == null) segment = nil;
          
            generated_column = $rb_plus(generated_column, segment['$[]'](0));
            generated = Opal.const_get_relative($nesting, 'Offset').$new(generated_line, generated_column);
            if ($truthy($rb_ge(segment.$size(), 4))) {
              
              source_id = $rb_plus(source_id, segment['$[]'](1));
              original_line = $rb_plus(original_line, segment['$[]'](2));
              original_column = $rb_plus(original_column, segment['$[]'](3));
              source = sources['$[]'](source_id);
              original = Opal.const_get_relative($nesting, 'Offset').$new(original_line, original_column);
              } else {
              return nil;
            };
            if ($truthy(segment['$[]'](4))) {
              
              name_id = $rb_plus(name_id, segment['$[]'](4));
              name = names['$[]'](name_id);};
            return mappings['$<<'](Opal.const_get_relative($nesting, 'Mapping').$new(source, generated, original, name));}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3));
        return mappings;
      }, TMP_Map_decode_vlq_mappings_5.$$arity = -2);
      
      Opal.defn(self, '$initialize', TMP_Map_initialize_6 = function $$initialize(mappings, filename) {
        var $a, self = this;

        if (mappings == null) {
          mappings = [];
        }
        if (filename == null) {
          filename = nil;
        }
        return $a = [mappings, filename], (self.mappings = $a[0]), (self.filename = $a[1]), $a
      }, TMP_Map_initialize_6.$$arity = -1);
      self.$attr_reader("filename");
      
      Opal.defn(self, '$size', TMP_Map_size_7 = function $$size() {
        var self = this;

        return self.mappings.$size()
      }, TMP_Map_size_7.$$arity = 0);
      
      Opal.defn(self, '$[]', TMP_Map_$$_8 = function(i) {
        var self = this;

        return self.mappings['$[]'](i)
      }, TMP_Map_$$_8.$$arity = 1);
      
      Opal.defn(self, '$each', TMP_Map_each_9 = function $$each() {
        var self = this, $iter = TMP_Map_each_9.$$p, block = $iter || nil;

        if ($iter) TMP_Map_each_9.$$p = null;
        return $send(self.mappings, 'each', [], block.$to_proc())
      }, TMP_Map_each_9.$$arity = 0);
      
      Opal.defn(self, '$to_s', TMP_Map_to_s_10 = function $$to_s() {
        var $a, self = this;

        return (self.string = ($truthy($a = self.string) ? $a : self.$build_vlq_string()))
      }, TMP_Map_to_s_10.$$arity = 0);
      
      Opal.defn(self, '$sources', TMP_Map_sources_11 = function $$sources() {
        var $a, self = this;

        return (self.sources = ($truthy($a = self.sources) ? $a : $send(self.mappings, 'map', [], "source".$to_proc()).$uniq().$compact()))
      }, TMP_Map_sources_11.$$arity = 0);
      
      Opal.defn(self, '$names', TMP_Map_names_12 = function $$names() {
        var $a, self = this;

        return (self.names = ($truthy($a = self.names) ? $a : $send(self.mappings, 'map', [], "name".$to_proc()).$uniq().$compact()))
      }, TMP_Map_names_12.$$arity = 0);
      
      Opal.defn(self, '$==', TMP_Map_$eq$eq_13 = function(other) {
        var self = this;

        return self['$eql?'](other)
      }, TMP_Map_$eq$eq_13.$$arity = 1);
      
      Opal.defn(self, '$eql?', TMP_Map_eql$q_14 = function(other) {
        var $a, $b, self = this;

        return ($truthy($a = ($truthy($b = other['$is_a?'](self.$class())) ? self.$mappings()['$=='](other.$mappings()) : $b)) ? self.$filename()['$=='](other.$filename()) : $a)
      }, TMP_Map_eql$q_14.$$arity = 1);
      
      Opal.defn(self, '$+', TMP_Map_$_16 = function(other) {
        var TMP_15, self = this, mappings = nil, offset = nil;

        
        mappings = self.mappings.$dup();
        offset = (function() {if ($truthy(self.mappings['$any?']())) {
          return $rb_plus(self.mappings.$last().$generated().$line(), 1)
          } else {
          return 0
        }; return nil; })();
        $send(other, 'each', [], (TMP_15 = function(m){var self = TMP_15.$$s || this;
if (m == null) m = nil;
        return mappings['$<<'](Opal.const_get_relative($nesting, 'Mapping').$new(m.$source(), $rb_plus(m.$generated(), offset), m.$original(), m.$name()))}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));
        return self.$class().$new(mappings, other.$filename());
      }, TMP_Map_$_16.$$arity = 1);
      
      Opal.defn(self, '$|', TMP_Map_$_18 = function(other) {
        var TMP_17, self = this, mappings = nil;

        
        if ($truthy(self.$mappings()['$empty?']())) {
          return other.$dup()};
        mappings = [];
        $send(other, 'each', [], (TMP_17 = function(m){var self = TMP_17.$$s || this, om = nil;
if (m == null) m = nil;
        
          om = self.$bsearch(m.$original());
          if ($truthy(om)) {
            } else {
            return nil;
          };
          return mappings['$<<'](Opal.const_get_relative($nesting, 'Mapping').$new(om.$source(), m.$generated(), om.$original(), om.$name()));}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17));
        return self.$class().$new(mappings, other.$filename());
      }, TMP_Map_$_18.$$arity = 1);
      
      Opal.defn(self, '$bsearch', TMP_Map_bsearch_19 = function $$bsearch(offset, from, to) {
        var self = this, mid = nil;

        if (from == null) {
          from = 0;
        }
        if (to == null) {
          to = $rb_minus(self.$size(), 1);
        }
        
        mid = $rb_divide($rb_plus(from, to), 2);
        if ($truthy($rb_gt(from, to))) {
          return (function() {if ($truthy($rb_lt(from, 1))) {
            return nil
            } else {
            return self['$[]']($rb_minus(from, 1))
          }; return nil; })()};
        if (offset['$=='](self['$[]'](mid).$generated())) {
          return self['$[]'](mid)
        } else if ($truthy($rb_lt(offset, self['$[]'](mid).$generated()))) {
          return self.$bsearch(offset, from, $rb_minus(mid, 1))
        } else if ($truthy($rb_gt(offset, self['$[]'](mid).$generated()))) {
          return self.$bsearch(offset, $rb_plus(mid, 1), to)
          } else {
          return nil
        };
      }, TMP_Map_bsearch_19.$$arity = -2);
      
      Opal.defn(self, '$as_json', TMP_Map_as_json_20 = function $$as_json() {
        var self = this;

        return $hash2(["version", "file", "mappings", "sources", "names"], {"version": 3, "file": self.$filename(), "mappings": self.$to_s(), "sources": self.$sources(), "names": self.$names()})
      }, TMP_Map_as_json_20.$$arity = 0);
      
      Opal.defn(self, '$inspect', TMP_Map_inspect_21 = function $$inspect() {
        var self = this, str = nil;

        
        str = "" + "#<" + (self.$class());
        if ($truthy(self.$filename())) {
          str['$<<']("" + " filename=" + (self.$filename().$inspect()))};
        if ($truthy(self.$mappings()['$any?']())) {
          str['$<<']("" + " mappings=" + ($send(self.$mappings(), 'map', [], "to_s".$to_proc()).$inspect()))};
        str['$<<'](">");
        return str;
      }, TMP_Map_inspect_21.$$arity = 0);
      self.$protected();
      self.$attr_reader("mappings");
      return (Opal.defn(self, '$build_vlq_string', TMP_Map_build_vlq_string_25 = function $$build_vlq_string() {
        var TMP_22, $a, TMP_23, self = this, source_id = nil, source_line = nil, source_column = nil, name_id = nil, by_lines = nil, sources_index = nil, names_index = nil, ary = nil;

        
        source_id = 0;
        source_line = 1;
        source_column = 0;
        name_id = 0;
        by_lines = $send(self.mappings, 'group_by', [], (TMP_22 = function(m){var self = TMP_22.$$s || this;
if (m == null) m = nil;
        return m.$generated().$line()}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));
        sources_index = Opal.const_get_relative($nesting, 'Hash')['$[]'](self.$sources().$each_with_index().$to_a());
        names_index = Opal.const_get_relative($nesting, 'Hash')['$[]'](self.$names().$each_with_index().$to_a());
        ary = $send(Opal.Range.$new(1, ($truthy($a = by_lines.$keys().$max()) ? $a : 1), false), 'map', [], (TMP_23 = function(line){var self = TMP_23.$$s || this, $b, TMP_24, generated_column = nil;
if (line == null) line = nil;
        
          generated_column = 0;
          return $send(($truthy($b = by_lines['$[]'](line)) ? $b : []), 'map', [], (TMP_24 = function(mapping){var self = TMP_24.$$s || this, group = nil;
if (mapping == null) mapping = nil;
          
            group = [];
            group['$<<']($rb_minus(mapping.$generated().$column(), generated_column));
            group['$<<']($rb_minus(sources_index['$[]'](mapping.$source()), source_id));
            group['$<<']($rb_minus(mapping.$original().$line(), source_line));
            group['$<<']($rb_minus(mapping.$original().$column(), source_column));
            if ($truthy(mapping.$name())) {
              group['$<<']($rb_minus(names_index['$[]'](mapping.$name()), name_id))};
            generated_column = mapping.$generated().$column();
            source_id = sources_index['$[]'](mapping.$source());
            source_line = mapping.$original().$line();
            source_column = mapping.$original().$column();
            if ($truthy(mapping.$name())) {
              name_id = names_index['$[]'](mapping.$name())};
            return group;}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24));}, TMP_23.$$s = self, TMP_23.$$arity = 1, TMP_23));
        return Opal.const_get_relative($nesting, 'VLQ').$encode_mappings(ary);
      }, TMP_Map_build_vlq_string_25.$$arity = 0), nil) && 'build_vlq_string';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["source_map/version"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var $SourceMap, self = $SourceMap = $module($base, 'SourceMap');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    Opal.const_set($nesting[0], 'VERSION', "0.0.2")
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["source_map"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("source_map/map");
  self.$require("source_map/mapping");
  self.$require("source_map/offset");
  self.$require("source_map/version");
  return self.$require("source_map/vlq");
};
